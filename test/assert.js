// This file has been adapted from the zora.js assertion part.
//
function equal(a, b) {
  if (a === b) {
    return true;
  }

  if (a && b && typeof a === 'object' && typeof b === 'object') {
    if (a.constructor !== b.constructor) {
      return false;
    }

    let length;
    let i;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) {
        return false;
      }

      for (i = length; i-- !== 0;) {
        if (!equal(a[i], b[i])) {
          return false;
        }
      }

      return true;
    }

    if (a.constructor === RegExp) {
      return a.source === b.source && a.flags === b.flags;
    }

    if (a.valueOf && a.valueOf !== Object.prototype.valueOf) {
      return a.valueOf() === b.valueOf();
    }

    if (a.toString && a.toString !== Object.prototype.toString) {
      return a.toString() === b.toString();
    }

    const keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }

    for (i = length; i-- !== 0;) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }

    for (i = length; i-- !== 0;) {
      const key = keys[i];

      if (!equal(a[key], b[key])) {
        return false;
      }
    }

    return true;
  }

  // True if both NaN, false otherwise
  return a !== a && b !== b; // eslint-disable-line
}

const fastDeepEqual = equal;

class AssertionError extends Error {
  constructor(result) {
    super(result.description);
    this.name = 'AssertionError';
    const stack = this.stack
      .split('\n')
      .map(l => l.trim())
      .find(l => l && !/assert.js/.test(l));
    const stackLine = stack.replace(/^at/, '').trim();
    this.stack = [
      `at: ${stackLine}`,
      `wanted: ${result.expected}`,
      `found: ${result.actual}`,
      `operator: ${result.operator}`,
    ].join('\n');
  }
}

const assertMethodHook = fn => function (...args) {
  const result = fn(...args);
  if (!result.pass) {
    throw new AssertionError(result);
  }
};

const aliasMethodHook = methodName => function (...args) {
  return this[methodName](...args);
};

const AssertPrototype = {
  equal: assertMethodHook((actual, expected, description = 'should be equivalent') => ({
    pass: fastDeepEqual(actual, expected),
    actual,
    expected,
    description,
    operator: 'equal', /* EQUAL */
  })),
  equals: aliasMethodHook('equal'),
  eq: aliasMethodHook('equal'),
  deepEqual: aliasMethodHook('equal'),
  notEqual: assertMethodHook((actual, expected, description = 'should not be equivalent') => ({
    pass: !fastDeepEqual(actual, expected),
    actual,
    expected,
    description,
    operator: 'notEqual', /* NOT_EQUAL */
  })),
  notEquals: aliasMethodHook('notEqual'),
  notEq: aliasMethodHook('notEqual'),
  notDeepEqual: aliasMethodHook('notEqual'),
  is: assertMethodHook((actual, expected, description = 'should be the same') => ({
    pass: Object.is(actual, expected),
    actual,
    expected,
    description,
    operator: 'is', /* IS */
  })),
  same: aliasMethodHook('is'),
  isNot: assertMethodHook((actual, expected, description = 'should not be the same') => ({
    pass: !Object.is(actual, expected),
    actual,
    expected,
    description,
    operator: 'isNot', /* IS_NOT */
  })),
  notSame: aliasMethodHook('isNot'),
  ok: assertMethodHook((actual, description = 'should be truthy') => ({
    pass: Boolean(actual),
    actual,
    expected: 'truthy value',
    description,
    operator: 'ok', /* OK */
  })),
  truthy: aliasMethodHook('ok'),
  notOk: assertMethodHook((actual, description = 'should be falsy') => ({
    pass: !actual,
    actual,
    expected: 'falsy value',
    description,
    operator: 'notOk', /* NOT_OK */
  })),
  falsy: aliasMethodHook('notOk'),
  fail: assertMethodHook((description = 'fail called') => ({
    pass: false,
    actual: 'fail called',
    expected: 'fail not called',
    description,
    operator: 'fail', /* FAIL */
  })),
  throws: assertMethodHook((func, expected, description) => {
    let caught;
    let pass;
    let actual;
    if (typeof expected === 'string') {
      [expected, description] = [description, expected];
    }

    try {
      func();
    } catch (error) {
      caught = {error};
    }

    pass = caught !== undefined;
    actual = caught && caught.error;
    if (expected instanceof RegExp) {
      pass = expected.test(actual) || expected.test(actual && actual.message);
      actual = (actual && actual.message) || actual;
      expected = String(expected);
    } else if (typeof expected === 'function' && caught) {
      pass = actual instanceof expected;
      actual = actual.constructor;
    }

    return {
      pass,
      actual,
      expected,
      description: description || 'should throw',
      operator: 'throws', /* THROWS */
    };
  }),
  doesNotThrow: assertMethodHook((func, expected, description) => {
    let caught;
    if (typeof expected === 'string') {
      [expected, description] = [description, expected];
    }

    try {
      func();
    } catch (error) {
      caught = {error};
    }

    return {
      pass: caught === undefined,
      expected: 'no thrown error',
      actual: caught && caught.error,
      operator: 'doesNotThrow' /* DOES_NOT_THROW */,
      description: description || 'should not throw',
    };
  }),
};

export default AssertPrototype;
